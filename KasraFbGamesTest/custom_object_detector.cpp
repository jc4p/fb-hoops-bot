/*
	NOTE: This is not compiled as part of the Visual Studio project.
		  This file is the source of the compiled custom_object_detector.exe included in this repo.

		  Compiling it requires a machine with dlib installed, see the file this was
		  created from for more info and how to train: http://dlib.net/fhog_object_detector_ex.cpp.html
*/


#include <dlib/svm_threaded.h>
#include <dlib/string.h>
#include <dlib/image_processing.h>
#include <dlib/data_io.h>
#include <dlib/cmd_line_parser.h>

#include <iostream>
#include <fstream>

using namespace std;
using namespace dlib;

int main(int argc, char** argv)
{  
    try
    {
        command_line_parser parser;
        parser.add_option("h","Display this help message.");
        parser.parse(argc, argv);

        // Turning this 3 into a 2 will disable the last layer, which is the basketball.
        typedef scan_fhog_pyramid<pyramid_down<3> > image_scanner_type; 

        const char* one_time_opts[] = {"h"};
        parser.check_one_time_options(one_time_opts);

        if (parser.option("h"))
        {
            cout << "Usage: train_object_detector [options] <path to detector files> <image file>\n";
            parser.print_options(); 
                                       
            return EXIT_SUCCESS;
        }

        if (parser.number_of_arguments() != 2)
        {
            cout << "You must supply a training dataset generated by the imglab tool alongside an image to analyze." << endl;
            cout << "\nTry the -h option for more information." << endl;

            return EXIT_FAILURE;
        }

        // load a previously trained object detector and try it out on some data
        ifstream ball_fin(parser[0] + "/ball_detector.svm", ios::binary);
        ifstream net_fin(parser[0] + "/net_detector.svm", ios::binary);
        if (!ball_fin || !net_fin)
        {
            cout << "Can't find ball_detector.svm and net_detector.svm" << endl;
            cout << "in path " << parser[0] << "/." << endl; 
            cout << "\nTry the -h option for more information." << endl;

            return EXIT_FAILURE;
        }

        image_scanner_type scanner;

        object_detector<image_scanner_type> ball_detector;
        object_detector<image_scanner_type> net_detector;
        deserialize(ball_detector, ball_fin);
        deserialize(net_detector, net_fin);

        dlib::array<array2d<unsigned char> > images;
        // Leaving this as a loop in case we want to handle multiple images at once later
        //images.resize(parser.number_of_arguments());
        images.resize(1);
        for (unsigned long i = 0; i < images.size(); ++i)
            load_image(images[i], parser[i + 1]); // parser[i + 1] since parser[0] is the detector path

        for (unsigned long i = 0; i < images.size(); ++i)
        {
            // Run the detector on images[i] 
            const std::vector<rectangle> ball_rects = ball_detector(images[i]);
            const std::vector<rectangle> net_rects = net_detector(images[i]);

            if (ball_rects.size() == 1 && net_rects.size() == 1) {
                cout << "{\"net\":" << " {\"left\": " << net_rects[0].left() << ", \"top\": " << net_rects[0].top() << ", \"right\": " << net_rects[0].right() << ", \"bottom\": " << net_rects[0].bottom() << "}," << endl;
                cout << "\"ball\":" << " {\"left\": " << ball_rects[0].left() << ", \"top\": " << ball_rects[0].top() << ", \"right\": " << ball_rects[0].right() << ", \"bottom\": " << ball_rects[0].bottom() << "}}" << endl;
            }
        }
    }
    catch (exception& e)
    {
        cout << "\nexception thrown!" << endl;
        cout << e.what() << endl;
        cout << "\nTry the -h option for more information." << endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}